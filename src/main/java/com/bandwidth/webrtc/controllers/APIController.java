/*
 * BandwidthLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */
package com.bandwidth.webrtc.controllers;

import java.io.IOException;
import java.util.AbstractMap.SimpleEntry;
import java.util.concurrent.CompletableFuture;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.bandwidth.ApiHelper;
import com.bandwidth.AuthManager;
import com.bandwidth.Configuration;
import com.bandwidth.controllers.BaseController;
import com.bandwidth.exceptions.ApiException;
import com.bandwidth.http.client.HttpClient;
import com.bandwidth.http.client.HttpContext;
import com.bandwidth.http.Headers;
import com.bandwidth.http.request.HttpRequest;
import com.bandwidth.http.response.ApiResponse;
import com.bandwidth.http.response.HttpResponse;
import com.bandwidth.http.response.HttpStringResponse;
import com.bandwidth.Server;
import com.bandwidth.webrtc.exceptions.ErrorException;
import com.bandwidth.webrtc.models.AccountsParticipantsResponse;
import com.bandwidth.webrtc.models.Participant;
import com.bandwidth.webrtc.models.Session;
import com.bandwidth.webrtc.models.Subscriptions;

/**
 * This class lists all the endpoints of the groups.
 */
public final class APIController extends BaseController {

    /**
     * Initializes the controller.
     * @param config
     * @param httpClient
     * @param authManagers
     */
    public APIController(Configuration config, HttpClient httpClient, Map<String, AuthManager> authManagers) {
        super(config, httpClient, authManagers);
    }


    /**
     * Create a new participant under this account
     * Participants are idempotent, so relevant parameters must be set in this function if desired
     * @param    accountId    Required parameter: Account ID
     * @param    body    Optional parameter: Participant parameters
     * @return    Returns the ApiResponse<AccountsParticipantsResponse> response from the API call
     */
    public ApiResponse<AccountsParticipantsResponse> createParticipant(
            final String accountId,
            final Participant body) throws ApiException, IOException {
        HttpRequest request = buildCreateParticipantRequest(accountId, body);
        authManagers.get("webRtc").apply(request);

        HttpResponse response = getClientInstance().executeAsString(request);
        HttpContext context = new HttpContext(request, response);

        return handleCreateParticipantResponse(context);
    }

    /**
     * Create a new participant under this account
     * Participants are idempotent, so relevant parameters must be set in this function if desired
     * @param    accountId    Required parameter: Account ID
     * @param    body    Optional parameter: Participant parameters
     * @return    Returns the ApiResponse<AccountsParticipantsResponse> response from the API call 
     */
    public CompletableFuture<ApiResponse<AccountsParticipantsResponse>> createParticipantAsync(
            final String accountId,
            final Participant body) {
        return makeHttpCallAsync(() -> buildCreateParticipantRequest(accountId, body),
                req -> authManagers.get("webRtc").applyAsync(req)
                    .thenCompose(request -> getClientInstance().executeAsStringAsync(request)),
                context -> handleCreateParticipantResponse(context));
    }

    /**
     * Builds the HttpRequest object for createParticipant
     */
    private HttpRequest buildCreateParticipantRequest(
            final String accountId,
            final Participant body) throws JsonProcessingException {
        //the base uri for api requests
        String baseUri = config.getBaseUri(Server.WEBRTCDEFAULT);

        //prepare query string for API call
        StringBuilder queryBuilder = new StringBuilder(baseUri + "/accounts/{accountId}/participants");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("accountId", new SimpleEntry<Object, Boolean>(accountId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");
        headers.add("content-type", "application/json");

        //prepare and invoke the API call request to fetch the response
        String bodyJson = ApiHelper.serialize(body);
        HttpRequest request = getClientInstance().postBody(queryBuilder, headers, null, bodyJson);

        return request;
    }

    /**
     * Processes the response for createParticipant
     * @return An object of type AccountsParticipantsResponse
     */
    private ApiResponse<AccountsParticipantsResponse> handleCreateParticipantResponse(HttpContext context)
            throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if (responseCode == 400) {
            throw new ApiException("Bad Request", context);
        }
        if (responseCode == 401) {
            throw new ApiException("Unauthorized", context);
        }
        if (responseCode == 403) {
            throw new ApiException("Access Denied", context);
        }
        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorException("Unexpected Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse)response).getBody();
        AccountsParticipantsResponse result = ApiHelper.deserialize(responseBody,
                AccountsParticipantsResponse.class);

        return new ApiResponse<AccountsParticipantsResponse>(response.getStatusCode(), response.getHeaders(), result);
    }

    /**
     * Get participant by ID
     * @param    accountId    Required parameter: Account ID
     * @param    participantId    Required parameter: Participant ID
     * @return    Returns the ApiResponse<Participant> response from the API call
     */
    public ApiResponse<Participant> getParticipant(
            final String accountId,
            final String participantId) throws ApiException, IOException {
        HttpRequest request = buildGetParticipantRequest(accountId, participantId);
        authManagers.get("webRtc").apply(request);

        HttpResponse response = getClientInstance().executeAsString(request);
        HttpContext context = new HttpContext(request, response);

        return handleGetParticipantResponse(context);
    }

    /**
     * Get participant by ID
     * @param    accountId    Required parameter: Account ID
     * @param    participantId    Required parameter: Participant ID
     * @return    Returns the ApiResponse<Participant> response from the API call 
     */
    public CompletableFuture<ApiResponse<Participant>> getParticipantAsync(
            final String accountId,
            final String participantId) {
        return makeHttpCallAsync(() -> buildGetParticipantRequest(accountId, participantId),
                req -> authManagers.get("webRtc").applyAsync(req)
                    .thenCompose(request -> getClientInstance().executeAsStringAsync(request)),
                context -> handleGetParticipantResponse(context));
    }

    /**
     * Builds the HttpRequest object for getParticipant
     */
    private HttpRequest buildGetParticipantRequest(
            final String accountId,
            final String participantId) {
        //the base uri for api requests
        String baseUri = config.getBaseUri(Server.WEBRTCDEFAULT);

        //prepare query string for API call
        StringBuilder queryBuilder = new StringBuilder(baseUri + "/accounts/{accountId}/participants/{participantId}");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("accountId", new SimpleEntry<Object, Boolean>(accountId, true));
        templateParameters.put("participantId", new SimpleEntry<Object, Boolean>(participantId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().get(queryBuilder, headers, null, null);

        return request;
    }

    /**
     * Processes the response for getParticipant
     * @return An object of type Participant
     */
    private ApiResponse<Participant> handleGetParticipantResponse(HttpContext context)
            throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if (responseCode == 401) {
            throw new ApiException("Unauthorized", context);
        }
        if (responseCode == 403) {
            throw new ApiException("Access Denied", context);
        }
        if (responseCode == 404) {
            throw new ApiException("Not Found", context);
        }
        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorException("Unexpected Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse)response).getBody();
        Participant result = ApiHelper.deserialize(responseBody,
                Participant.class);

        return new ApiResponse<Participant>(response.getStatusCode(), response.getHeaders(), result);
    }

    /**
     * Delete participant by ID
     * @param    accountId    Required parameter: Account ID
     * @param    participantId    Required parameter: Example: 
     */
    public ApiResponse<Void> deleteParticipant(
            final String accountId,
            final String participantId) throws ApiException, IOException {
        HttpRequest request = buildDeleteParticipantRequest(accountId, participantId);
        authManagers.get("webRtc").apply(request);

        HttpResponse response = getClientInstance().executeAsString(request);
        HttpContext context = new HttpContext(request, response);

        return handleDeleteParticipantResponse(context);
    }

    /**
     * Delete participant by ID
     * @param    accountId    Required parameter: Account ID
     * @param    participantId    Required parameter: Example: 
     * @return    Returns the ApiResponse<Void> response from the API call 
     */
    public CompletableFuture<ApiResponse<Void>> deleteParticipantAsync(
            final String accountId,
            final String participantId) {
        return makeHttpCallAsync(() -> buildDeleteParticipantRequest(accountId, participantId),
                req -> authManagers.get("webRtc").applyAsync(req)
                    .thenCompose(request -> getClientInstance().executeAsStringAsync(request)),
                context -> handleDeleteParticipantResponse(context));
    }

    /**
     * Builds the HttpRequest object for deleteParticipant
     */
    private HttpRequest buildDeleteParticipantRequest(
            final String accountId,
            final String participantId) {
        //the base uri for api requests
        String baseUri = config.getBaseUri(Server.WEBRTCDEFAULT);

        //prepare query string for API call
        StringBuilder queryBuilder = new StringBuilder(baseUri + "/accounts/{accountId}/participants/{participantId}");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("accountId", new SimpleEntry<Object, Boolean>(accountId, true));
        templateParameters.put("participantId", new SimpleEntry<Object, Boolean>(participantId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().delete(queryBuilder, headers, null, null);

        return request;
    }

    /**
     * Processes the response for deleteParticipant
     * @return An object of type void
     */
    private ApiResponse<Void> handleDeleteParticipantResponse(HttpContext context)
            throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if (responseCode == 401) {
            throw new ApiException("Unauthorized", context);
        }
        if (responseCode == 403) {
            throw new ApiException("Access Denied", context);
        }
        if (responseCode == 404) {
            throw new ApiException("Not Found", context);
        }
        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorException("Unexpected Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        return new ApiResponse<Void>(response.getStatusCode(), response.getHeaders(), null);
    }

    /**
     * Create a new session
     * Sessions are idempotent, so relevant parameters must be set in this function if desired
     * @param    accountId    Required parameter: Account ID
     * @param    body    Optional parameter: Session parameters
     * @return    Returns the ApiResponse<Session> response from the API call
     */
    public ApiResponse<Session> createSession(
            final String accountId,
            final Session body) throws ApiException, IOException {
        HttpRequest request = buildCreateSessionRequest(accountId, body);
        authManagers.get("webRtc").apply(request);

        HttpResponse response = getClientInstance().executeAsString(request);
        HttpContext context = new HttpContext(request, response);

        return handleCreateSessionResponse(context);
    }

    /**
     * Create a new session
     * Sessions are idempotent, so relevant parameters must be set in this function if desired
     * @param    accountId    Required parameter: Account ID
     * @param    body    Optional parameter: Session parameters
     * @return    Returns the ApiResponse<Session> response from the API call 
     */
    public CompletableFuture<ApiResponse<Session>> createSessionAsync(
            final String accountId,
            final Session body) {
        return makeHttpCallAsync(() -> buildCreateSessionRequest(accountId, body),
                req -> authManagers.get("webRtc").applyAsync(req)
                    .thenCompose(request -> getClientInstance().executeAsStringAsync(request)),
                context -> handleCreateSessionResponse(context));
    }

    /**
     * Builds the HttpRequest object for createSession
     */
    private HttpRequest buildCreateSessionRequest(
            final String accountId,
            final Session body) throws JsonProcessingException {
        //the base uri for api requests
        String baseUri = config.getBaseUri(Server.WEBRTCDEFAULT);

        //prepare query string for API call
        StringBuilder queryBuilder = new StringBuilder(baseUri + "/accounts/{accountId}/sessions");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("accountId", new SimpleEntry<Object, Boolean>(accountId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");
        headers.add("content-type", "application/json");

        //prepare and invoke the API call request to fetch the response
        String bodyJson = ApiHelper.serialize(body);
        HttpRequest request = getClientInstance().postBody(queryBuilder, headers, null, bodyJson);

        return request;
    }

    /**
     * Processes the response for createSession
     * @return An object of type Session
     */
    private ApiResponse<Session> handleCreateSessionResponse(HttpContext context)
            throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if (responseCode == 400) {
            throw new ApiException("Bad Request", context);
        }
        if (responseCode == 401) {
            throw new ApiException("Unauthorized", context);
        }
        if (responseCode == 403) {
            throw new ApiException("Access Denied", context);
        }
        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorException("Unexpected Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse)response).getBody();
        Session result = ApiHelper.deserialize(responseBody,
                Session.class);

        return new ApiResponse<Session>(response.getStatusCode(), response.getHeaders(), result);
    }

    /**
     * Get session by ID
     * @param    accountId    Required parameter: Account ID
     * @param    sessionId    Required parameter: Session ID
     * @return    Returns the ApiResponse<Session> response from the API call
     */
    public ApiResponse<Session> getSession(
            final String accountId,
            final String sessionId) throws ApiException, IOException {
        HttpRequest request = buildGetSessionRequest(accountId, sessionId);
        authManagers.get("webRtc").apply(request);

        HttpResponse response = getClientInstance().executeAsString(request);
        HttpContext context = new HttpContext(request, response);

        return handleGetSessionResponse(context);
    }

    /**
     * Get session by ID
     * @param    accountId    Required parameter: Account ID
     * @param    sessionId    Required parameter: Session ID
     * @return    Returns the ApiResponse<Session> response from the API call 
     */
    public CompletableFuture<ApiResponse<Session>> getSessionAsync(
            final String accountId,
            final String sessionId) {
        return makeHttpCallAsync(() -> buildGetSessionRequest(accountId, sessionId),
                req -> authManagers.get("webRtc").applyAsync(req)
                    .thenCompose(request -> getClientInstance().executeAsStringAsync(request)),
                context -> handleGetSessionResponse(context));
    }

    /**
     * Builds the HttpRequest object for getSession
     */
    private HttpRequest buildGetSessionRequest(
            final String accountId,
            final String sessionId) {
        //the base uri for api requests
        String baseUri = config.getBaseUri(Server.WEBRTCDEFAULT);

        //prepare query string for API call
        StringBuilder queryBuilder = new StringBuilder(baseUri + "/accounts/{accountId}/sessions/{sessionId}");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("accountId", new SimpleEntry<Object, Boolean>(accountId, true));
        templateParameters.put("sessionId", new SimpleEntry<Object, Boolean>(sessionId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().get(queryBuilder, headers, null, null);

        return request;
    }

    /**
     * Processes the response for getSession
     * @return An object of type Session
     */
    private ApiResponse<Session> handleGetSessionResponse(HttpContext context)
            throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if (responseCode == 401) {
            throw new ApiException("Unauthorized", context);
        }
        if (responseCode == 403) {
            throw new ApiException("Access Denied", context);
        }
        if (responseCode == 404) {
            throw new ApiException("Not Found", context);
        }
        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorException("Unexpected Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse)response).getBody();
        Session result = ApiHelper.deserialize(responseBody,
                Session.class);

        return new ApiResponse<Session>(response.getStatusCode(), response.getHeaders(), result);
    }

    /**
     * Delete session by ID
     * @param    accountId    Required parameter: Account ID
     * @param    sessionId    Required parameter: Session ID
     */
    public ApiResponse<Void> deleteSession(
            final String accountId,
            final String sessionId) throws ApiException, IOException {
        HttpRequest request = buildDeleteSessionRequest(accountId, sessionId);
        authManagers.get("webRtc").apply(request);

        HttpResponse response = getClientInstance().executeAsString(request);
        HttpContext context = new HttpContext(request, response);

        return handleDeleteSessionResponse(context);
    }

    /**
     * Delete session by ID
     * @param    accountId    Required parameter: Account ID
     * @param    sessionId    Required parameter: Session ID
     * @return    Returns the ApiResponse<Void> response from the API call 
     */
    public CompletableFuture<ApiResponse<Void>> deleteSessionAsync(
            final String accountId,
            final String sessionId) {
        return makeHttpCallAsync(() -> buildDeleteSessionRequest(accountId, sessionId),
                req -> authManagers.get("webRtc").applyAsync(req)
                    .thenCompose(request -> getClientInstance().executeAsStringAsync(request)),
                context -> handleDeleteSessionResponse(context));
    }

    /**
     * Builds the HttpRequest object for deleteSession
     */
    private HttpRequest buildDeleteSessionRequest(
            final String accountId,
            final String sessionId) {
        //the base uri for api requests
        String baseUri = config.getBaseUri(Server.WEBRTCDEFAULT);

        //prepare query string for API call
        StringBuilder queryBuilder = new StringBuilder(baseUri + "/accounts/{accountId}/sessions/{sessionId}");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("accountId", new SimpleEntry<Object, Boolean>(accountId, true));
        templateParameters.put("sessionId", new SimpleEntry<Object, Boolean>(sessionId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().delete(queryBuilder, headers, null, null);

        return request;
    }

    /**
     * Processes the response for deleteSession
     * @return An object of type void
     */
    private ApiResponse<Void> handleDeleteSessionResponse(HttpContext context)
            throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if (responseCode == 401) {
            throw new ApiException("Unauthorized", context);
        }
        if (responseCode == 403) {
            throw new ApiException("Access Denied", context);
        }
        if (responseCode == 404) {
            throw new ApiException("Not Found", context);
        }
        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorException("Unexpected Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        return new ApiResponse<Void>(response.getStatusCode(), response.getHeaders(), null);
    }

    /**
     * List participants in a session
     * @param    accountId    Required parameter: Account ID
     * @param    sessionId    Required parameter: Session ID
     * @return    Returns the ApiResponse<List<Participant>> response from the API call
     */
    public ApiResponse<List<Participant>> listSessionParticipants(
            final String accountId,
            final String sessionId) throws ApiException, IOException {
        HttpRequest request = buildListSessionParticipantsRequest(accountId, sessionId);
        authManagers.get("webRtc").apply(request);

        HttpResponse response = getClientInstance().executeAsString(request);
        HttpContext context = new HttpContext(request, response);

        return handleListSessionParticipantsResponse(context);
    }

    /**
     * List participants in a session
     * @param    accountId    Required parameter: Account ID
     * @param    sessionId    Required parameter: Session ID
     * @return    Returns the ApiResponse<List<Participant>> response from the API call 
     */
    public CompletableFuture<ApiResponse<List<Participant>>> listSessionParticipantsAsync(
            final String accountId,
            final String sessionId) {
        return makeHttpCallAsync(() -> buildListSessionParticipantsRequest(accountId, sessionId),
                req -> authManagers.get("webRtc").applyAsync(req)
                    .thenCompose(request -> getClientInstance().executeAsStringAsync(request)),
                context -> handleListSessionParticipantsResponse(context));
    }

    /**
     * Builds the HttpRequest object for listSessionParticipants
     */
    private HttpRequest buildListSessionParticipantsRequest(
            final String accountId,
            final String sessionId) {
        //the base uri for api requests
        String baseUri = config.getBaseUri(Server.WEBRTCDEFAULT);

        //prepare query string for API call
        StringBuilder queryBuilder = new StringBuilder(baseUri + "/accounts/{accountId}/sessions/{sessionId}/participants");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("accountId", new SimpleEntry<Object, Boolean>(accountId, true));
        templateParameters.put("sessionId", new SimpleEntry<Object, Boolean>(sessionId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().get(queryBuilder, headers, null, null);

        return request;
    }

    /**
     * Processes the response for listSessionParticipants
     * @return An object of type List<Participant>
     */
    private ApiResponse<List<Participant>> handleListSessionParticipantsResponse(HttpContext context)
            throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if (responseCode == 401) {
            throw new ApiException("Unauthorized", context);
        }
        if (responseCode == 403) {
            throw new ApiException("Access Denied", context);
        }
        if (responseCode == 404) {
            throw new ApiException("Not Found", context);
        }
        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorException("Unexpected Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse)response).getBody();
        List<Participant> result = ApiHelper.deserializeArray(responseBody,
                Participant[].class);
        return new ApiResponse<List<Participant>>(response.getStatusCode(), response.getHeaders(), result);
    }

    /**
     * Add a participant to a session
     * Subscriptions can optionally be provided as part of this call
     * @param    accountId    Required parameter: Account ID
     * @param    sessionId    Required parameter: Session ID
     * @param    participantId    Required parameter: Participant ID
     * @param    body    Optional parameter: Subscriptions the participant should be created with
     */
    public ApiResponse<Void> addParticipantToSession(
            final String accountId,
            final String sessionId,
            final String participantId,
            final Subscriptions body) throws ApiException, IOException {
        HttpRequest request = buildAddParticipantToSessionRequest(accountId, sessionId, participantId, body);
        authManagers.get("webRtc").apply(request);

        HttpResponse response = getClientInstance().executeAsString(request);
        HttpContext context = new HttpContext(request, response);

        return handleAddParticipantToSessionResponse(context);
    }

    /**
     * Add a participant to a session
     * Subscriptions can optionally be provided as part of this call
     * @param    accountId    Required parameter: Account ID
     * @param    sessionId    Required parameter: Session ID
     * @param    participantId    Required parameter: Participant ID
     * @param    body    Optional parameter: Subscriptions the participant should be created with
     * @return    Returns the ApiResponse<Void> response from the API call 
     */
    public CompletableFuture<ApiResponse<Void>> addParticipantToSessionAsync(
            final String accountId,
            final String sessionId,
            final String participantId,
            final Subscriptions body) {
        return makeHttpCallAsync(() -> buildAddParticipantToSessionRequest(accountId, sessionId, participantId, body),
                req -> authManagers.get("webRtc").applyAsync(req)
                    .thenCompose(request -> getClientInstance().executeAsStringAsync(request)),
                context -> handleAddParticipantToSessionResponse(context));
    }

    /**
     * Builds the HttpRequest object for addParticipantToSession
     */
    private HttpRequest buildAddParticipantToSessionRequest(
            final String accountId,
            final String sessionId,
            final String participantId,
            final Subscriptions body) throws JsonProcessingException {
        //the base uri for api requests
        String baseUri = config.getBaseUri(Server.WEBRTCDEFAULT);

        //prepare query string for API call
        StringBuilder queryBuilder = new StringBuilder(baseUri + "/accounts/{accountId}/sessions/{sessionId}/participants/{participantId}");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("accountId", new SimpleEntry<Object, Boolean>(accountId, true));
        templateParameters.put("sessionId", new SimpleEntry<Object, Boolean>(sessionId, true));
        templateParameters.put("participantId", new SimpleEntry<Object, Boolean>(participantId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("content-type", "application/json");

        //prepare and invoke the API call request to fetch the response
        String bodyJson = ApiHelper.serialize(body);
        HttpRequest request = getClientInstance().putBody(queryBuilder, headers, null, bodyJson);

        return request;
    }

    /**
     * Processes the response for addParticipantToSession
     * @return An object of type void
     */
    private ApiResponse<Void> handleAddParticipantToSessionResponse(HttpContext context)
            throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if (responseCode == 401) {
            throw new ApiException("Unauthorized", context);
        }
        if (responseCode == 403) {
            throw new ApiException("Access Denied", context);
        }
        if (responseCode == 404) {
            throw new ApiException("Not Found", context);
        }
        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorException("Unexpected Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        return new ApiResponse<Void>(response.getStatusCode(), response.getHeaders(), null);
    }

    /**
     * Remove a participant from a session
     * This will automatically remove any subscriptions the participant has associated with this session
     * @param    accountId    Required parameter: Account ID
     * @param    participantId    Required parameter: Participant ID
     * @param    sessionId    Required parameter: Session ID
     */
    public ApiResponse<Void> removeParticipantFromSession(
            final String accountId,
            final String participantId,
            final String sessionId) throws ApiException, IOException {
        HttpRequest request = buildRemoveParticipantFromSessionRequest(accountId, participantId, sessionId);
        authManagers.get("webRtc").apply(request);

        HttpResponse response = getClientInstance().executeAsString(request);
        HttpContext context = new HttpContext(request, response);

        return handleRemoveParticipantFromSessionResponse(context);
    }

    /**
     * Remove a participant from a session
     * This will automatically remove any subscriptions the participant has associated with this session
     * @param    accountId    Required parameter: Account ID
     * @param    participantId    Required parameter: Participant ID
     * @param    sessionId    Required parameter: Session ID
     * @return    Returns the ApiResponse<Void> response from the API call 
     */
    public CompletableFuture<ApiResponse<Void>> removeParticipantFromSessionAsync(
            final String accountId,
            final String participantId,
            final String sessionId) {
        return makeHttpCallAsync(() -> buildRemoveParticipantFromSessionRequest(accountId, participantId, sessionId),
                req -> authManagers.get("webRtc").applyAsync(req)
                    .thenCompose(request -> getClientInstance().executeAsStringAsync(request)),
                context -> handleRemoveParticipantFromSessionResponse(context));
    }

    /**
     * Builds the HttpRequest object for removeParticipantFromSession
     */
    private HttpRequest buildRemoveParticipantFromSessionRequest(
            final String accountId,
            final String participantId,
            final String sessionId) {
        //the base uri for api requests
        String baseUri = config.getBaseUri(Server.WEBRTCDEFAULT);

        //prepare query string for API call
        StringBuilder queryBuilder = new StringBuilder(baseUri + "/accounts/{accountId}/sessions/{sessionId}/participants/{participantId}");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("accountId", new SimpleEntry<Object, Boolean>(accountId, true));
        templateParameters.put("participantId", new SimpleEntry<Object, Boolean>(participantId, true));
        templateParameters.put("sessionId", new SimpleEntry<Object, Boolean>(sessionId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().delete(queryBuilder, headers, null, null);

        return request;
    }

    /**
     * Processes the response for removeParticipantFromSession
     * @return An object of type void
     */
    private ApiResponse<Void> handleRemoveParticipantFromSessionResponse(HttpContext context)
            throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if (responseCode == 401) {
            throw new ApiException("Unauthorized", context);
        }
        if (responseCode == 403) {
            throw new ApiException("Access Denied", context);
        }
        if (responseCode == 404) {
            throw new ApiException("Not Found", context);
        }
        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorException("Unexpected Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        return new ApiResponse<Void>(response.getStatusCode(), response.getHeaders(), null);
    }

    /**
     * Get a participant's subscriptions
     * @param    accountId    Required parameter: Account ID
     * @param    participantId    Required parameter: Participant ID
     * @param    sessionId    Required parameter: Session ID
     * @return    Returns the ApiResponse<Subscriptions> response from the API call
     */
    public ApiResponse<Subscriptions> getParticipantSubscriptions(
            final String accountId,
            final String participantId,
            final String sessionId) throws ApiException, IOException {
        HttpRequest request = buildGetParticipantSubscriptionsRequest(accountId, participantId, sessionId);
        authManagers.get("webRtc").apply(request);

        HttpResponse response = getClientInstance().executeAsString(request);
        HttpContext context = new HttpContext(request, response);

        return handleGetParticipantSubscriptionsResponse(context);
    }

    /**
     * Get a participant's subscriptions
     * @param    accountId    Required parameter: Account ID
     * @param    participantId    Required parameter: Participant ID
     * @param    sessionId    Required parameter: Session ID
     * @return    Returns the ApiResponse<Subscriptions> response from the API call 
     */
    public CompletableFuture<ApiResponse<Subscriptions>> getParticipantSubscriptionsAsync(
            final String accountId,
            final String participantId,
            final String sessionId) {
        return makeHttpCallAsync(() -> buildGetParticipantSubscriptionsRequest(accountId, participantId, sessionId),
                req -> authManagers.get("webRtc").applyAsync(req)
                    .thenCompose(request -> getClientInstance().executeAsStringAsync(request)),
                context -> handleGetParticipantSubscriptionsResponse(context));
    }

    /**
     * Builds the HttpRequest object for getParticipantSubscriptions
     */
    private HttpRequest buildGetParticipantSubscriptionsRequest(
            final String accountId,
            final String participantId,
            final String sessionId) {
        //the base uri for api requests
        String baseUri = config.getBaseUri(Server.WEBRTCDEFAULT);

        //prepare query string for API call
        StringBuilder queryBuilder = new StringBuilder(baseUri + "/accounts/{accountId}/sessions/{sessionId}/participants/{participantId}/subscriptions");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("accountId", new SimpleEntry<Object, Boolean>(accountId, true));
        templateParameters.put("participantId", new SimpleEntry<Object, Boolean>(participantId, true));
        templateParameters.put("sessionId", new SimpleEntry<Object, Boolean>(sessionId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("accept", "application/json");

        //prepare and invoke the API call request to fetch the response
        HttpRequest request = getClientInstance().get(queryBuilder, headers, null, null);

        return request;
    }

    /**
     * Processes the response for getParticipantSubscriptions
     * @return An object of type Subscriptions
     */
    private ApiResponse<Subscriptions> handleGetParticipantSubscriptionsResponse(HttpContext context)
            throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if (responseCode == 401) {
            throw new ApiException("Unauthorized", context);
        }
        if (responseCode == 403) {
            throw new ApiException("Access Denied", context);
        }
        if (responseCode == 404) {
            throw new ApiException("Not Found", context);
        }
        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorException("Unexpected Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        //extract result from the http response
        String responseBody = ((HttpStringResponse)response).getBody();
        Subscriptions result = ApiHelper.deserialize(responseBody,
                Subscriptions.class);

        return new ApiResponse<Subscriptions>(response.getStatusCode(), response.getHeaders(), result);
    }

    /**
     * Update a participant's subscriptions
     * This is a full update that will replace the participant's subscriptions. First call `getParticipantSubscriptions` if you need the current subscriptions. Call this function with no `Subscriptions` object to remove all subscriptions
     * @param    accountId    Required parameter: Account ID
     * @param    participantId    Required parameter: Participant ID
     * @param    sessionId    Required parameter: Session ID
     * @param    body    Optional parameter: Initial state
     */
    public ApiResponse<Void> updateParticipantSubscriptions(
            final String accountId,
            final String participantId,
            final String sessionId,
            final Subscriptions body) throws ApiException, IOException {
        HttpRequest request = buildUpdateParticipantSubscriptionsRequest(accountId, participantId, sessionId, body);
        authManagers.get("webRtc").apply(request);

        HttpResponse response = getClientInstance().executeAsString(request);
        HttpContext context = new HttpContext(request, response);

        return handleUpdateParticipantSubscriptionsResponse(context);
    }

    /**
     * Update a participant's subscriptions
     * This is a full update that will replace the participant's subscriptions. First call `getParticipantSubscriptions` if you need the current subscriptions. Call this function with no `Subscriptions` object to remove all subscriptions
     * @param    accountId    Required parameter: Account ID
     * @param    participantId    Required parameter: Participant ID
     * @param    sessionId    Required parameter: Session ID
     * @param    body    Optional parameter: Initial state
     * @return    Returns the ApiResponse<Void> response from the API call 
     */
    public CompletableFuture<ApiResponse<Void>> updateParticipantSubscriptionsAsync(
            final String accountId,
            final String participantId,
            final String sessionId,
            final Subscriptions body) {
        return makeHttpCallAsync(() -> buildUpdateParticipantSubscriptionsRequest(accountId, participantId, sessionId, body),
                req -> authManagers.get("webRtc").applyAsync(req)
                    .thenCompose(request -> getClientInstance().executeAsStringAsync(request)),
                context -> handleUpdateParticipantSubscriptionsResponse(context));
    }

    /**
     * Builds the HttpRequest object for updateParticipantSubscriptions
     */
    private HttpRequest buildUpdateParticipantSubscriptionsRequest(
            final String accountId,
            final String participantId,
            final String sessionId,
            final Subscriptions body) throws JsonProcessingException {
        //the base uri for api requests
        String baseUri = config.getBaseUri(Server.WEBRTCDEFAULT);

        //prepare query string for API call
        StringBuilder queryBuilder = new StringBuilder(baseUri + "/accounts/{accountId}/sessions/{sessionId}/participants/{participantId}/subscriptions");

        //process template parameters
        Map<String, SimpleEntry<Object, Boolean>> templateParameters = new HashMap<>();
        templateParameters.put("accountId", new SimpleEntry<Object, Boolean>(accountId, true));
        templateParameters.put("participantId", new SimpleEntry<Object, Boolean>(participantId, true));
        templateParameters.put("sessionId", new SimpleEntry<Object, Boolean>(sessionId, true));
        ApiHelper.appendUrlWithTemplateParameters(queryBuilder, templateParameters);

        //load all headers for the outgoing API request
        Headers headers = new Headers();
        headers.add("user-agent", BaseController.userAgent);
        headers.add("content-type", "application/json");

        //prepare and invoke the API call request to fetch the response
        String bodyJson = ApiHelper.serialize(body);
        HttpRequest request = getClientInstance().putBody(queryBuilder, headers, null, bodyJson);

        return request;
    }

    /**
     * Processes the response for updateParticipantSubscriptions
     * @return An object of type void
     */
    private ApiResponse<Void> handleUpdateParticipantSubscriptionsResponse(HttpContext context)
            throws ApiException, IOException {
        HttpResponse response = context.getResponse();

        //Error handling using HTTP status codes
        int responseCode = response.getStatusCode();

        if (responseCode == 400) {
            throw new ApiException("Bad Request", context);
        }
        if (responseCode == 401) {
            throw new ApiException("Unauthorized", context);
        }
        if (responseCode == 403) {
            throw new ApiException("Access Denied", context);
        }
        if (responseCode == 404) {
            throw new ApiException("Not Found", context);
        }
        if ((responseCode < 200) || (responseCode > 208)) {
            throw new ErrorException("Unexpected Error", context);
        }
        //handle errors defined at the API level
        validateResponse(response, context);

        return new ApiResponse<Void>(response.getStatusCode(), response.getHeaders(), null);
    }

}